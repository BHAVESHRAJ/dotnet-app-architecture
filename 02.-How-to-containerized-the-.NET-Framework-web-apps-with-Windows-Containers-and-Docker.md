##  Overview
Windows Containers should be used as a way to improve deployments to production, development and test environments of existing .NET applications based on .NET Framework technologies like MVC, Web Forms or WCF.

##  Goals for this walkthrough
Show you several alternatives on how to containerize an existing .NET Framework application:

1.	Containerized your application through Visual Studio 2017 Tools for Docker (VS 2017 or later).
2.	Containerized your application by manually adding the dockerfiles and using the Docker CLI.
3.	Containerized your application through Img2Docker tool (Open Source tool from Docker)

This Walkthrough covers the three approaches although it offers further details for the VS 2017 Tools for Docker approach.

##  Scenario
The diagram below shows the scenario for the containerized eShop legacy applications.
![image](https://user-images.githubusercontent.com/1712635/30395628-9c4bff98-987b-11e7-82ca-89a1648f3bdc.png)

## Prerequisites
- Windows 10 (For the developer machine)
- [Docker for Windows (Docker CE for Windows)](https://store.docker.com/editions/community/docker-ce-desktop-windows)
- Visual Studio 2017 (VS 15.3.3 or later)

## Containerizing your existing .NET applications with Visual Studio

### Configuring Docker for Windows to use Windows Containers instead of Linux Containers
Before you run the solution, you must make sure that you configure Docker to use Windows Containers. To do that, you right-click the Docker taskbar icon in Windows and select **Switch to Windows Containers**, as shown in the figure below.

![image](https://user-images.githubusercontent.com/1712635/30396197-b9d4e0be-987d-11e7-9e76-e982ab184e54.png)

If the menu item says "Switch to Linux containers", you are already running Docker with Windows Containers.

### Using Visual Studio to add Docker support to the application
Visual Studio 2017 provides great support for containerizing an application. You right-click the project node and then select **Add** and **Docker Support**. The Docker project template adds a new project to the solution called **docker-compose**. The project contains the Docker assets (simple .yml metadata files) that compose the Docker images and containers' startup settings you need, as shown in the figure below. 

![image](https://user-images.githubusercontent.com/1712635/30396480-99d5cf20-987e-11e7-984d-4ddf5244f516.png)

Then, in the next figure you can see how your project and solution has been modified with the Docker metadata.

![image](https://user-images.githubusercontent.com/1712635/30396518-bfafaae0-987e-11e7-8473-9cd08d32d80d.png)

In the simplest monolithic scenarios like this one, the application will be the single application service/container defined at the docker-compose.yml file that you will need to deploy. In other more complex scenarios like N-Tier applications, you will have a multi-container application defined in the docker-compose.yml file.
The template also changes your startup project to point to the docker-compose project so it will run on Docker when launching the solution. 
Pressing Ctrl+F5 or F5 now compiles the .NET application bits, creates the Docker image and launches the Docker container all in a single step for you, as shown in the next image.

![image](https://user-images.githubusercontent.com/1712635/30396561-e2fe2044-987e-11e7-9742-3f6a48c3ddde.png)

When VS is building the Docker image, the first time you do this, it takes considerable time (a few minutes). This is because the build process pulls down the base Windows Server Core image and the additional image for ASP.NET. Subsequent build and run cycles will be much faster.
Let’s take a deeper look at the files added by the Docker project template. It created several files for you. Visual Studio uses these files to create the Docker image and launch a container. You can use the same files from the CLI to run Docker commands manually with the Docker CLI commands like “docker run” and “docker-compose up”.
For each application or service in your solution Visual Studio adds a dockerfile to your project’s root folder, similar to the following Dockerfile example showing the basic settings for building a Docker image based on the Windows ASP.NET image that runs an ASP.NET site.

Sample Dockerfile:

    `FROM microsoft/aspnet  
    ARG source  
    WORKDIR /inetpub/wwwroot  
    COPY ${source:-obj/Docker/publish} . `

If your application were based on an older version of .NET Framework, like .NET Framework 3.5, you could use a similar base image directive like the following.

`FROM microsoft/dotnet-framework:3.5`

This previous Dockerfile will look very similar to those created for running an ASP.NET Core application in Linux containers. However, there are a few important differences. The most important difference is that the base image is microsoft/aspnet, which is an image based on Windows Server Core image that includes IIS, the .NET Framework and special optimizations for ASP.NET.
The other files in the docker-compose project are the Docker assets needed to build and configure the containers. 
Visual Studio puts the various docker-compose.yml files under one node (project) to highlight how they are used. The base docker-compose file contains the directives that are common to all configurations/environments. The docker-compose.override.yml file contains environment variables and related overrides for a by-default developer configuration. 

### Development and production environments

There are a couple of differences between the development configuration and a production configuration. In the development environment, you run the ASP.NET application and SQL Server in Windows Containers, within the same Docker host. In earlier sections, we mentioned that for development environments you could use a SQL localdb within the same application Windows Container or deploying an independent SQL Server Windows Container. 

The advantage of running the database along with the multiple application containers within the same Docker host (or even orchestrator cluster looking forward) is that you have a very predictable testing environment with a consistent database that can have the same pre-generated data generated when deploying to the testing environment in the Docker host. 
In the development environment, you usually run all the containers in the same environment, including the SQL databases, so it’ll be easier while developing and testing. 

In a production environment, you can decide if you want to run the application Windows Container in a single Docker host Azure VM, or in an orchestrator’s cluster like Service Fabric, and most of all, you will usually have the data stored in a high-available and production ready SQL environment like Azure SQL Database or Azure SQL Database Managed Instance. 

Additional resources 
- Lab: Modernize .NET Apps - for Ops
    https://github.com/docker/labs/tree/master/dockercon-us-2017/windows-modernize-aspnet-ops
- Lab: Modernize .NET Apps - for Devs
    https://github.com/docker/labs/tree/master/dockercon-us-2017/windows-modernize-aspnet-dev

## Containerizing your existing .NET applications with the Docker CLI and manually adding dockerfiles

While Visual Studio integration is part of adding Docker support to your solution, annd just by running the dockerized application with VS you are already creating the Docker images and deploying the containers in Docker, all in a single step ("F5 experience"), you can also containerize your application by manually adding the dockerfile and docker-compose files to your solution and then building the Docker images with the “docker build” CLI command and finally running the application from the command line, using the “docker-compose up” command or the “docker run command” as you can explorer in other Docker guidance like the “[Containerized Docker Application Lifecycle with Microsoft Platform and Tools](https://aka.ms/dockerlifecycleebook)” eBook.

In order to generate your application's .NET bits, you can do so from VS and the menu option "Publish", then with the option "to folder" as used in [this other Wiki procedure](https://github.com/dotnet-architecture/eShopModernizing/wiki/03.-How-to-deploy-your-Windows-Containers-based-app-into-Azure-VMs-(Including-CI-CD)). 

As an alternative option, in order to build the .NET bits from the CLI or from a CI pipeline, you need a build container or Docker build agent that will be internally using MSBuild to compile your .NET code. You can explore this walkthrough on "[How to create a custom image for a .NET Framework build container internally using MSBuild](https://github.com/docker/labs/tree/master/dockercon-us-2017/windows-modernize-aspnet-dev)". 

Once you produced the .NET bits of your application, ready for you, in a directory, you’d build the Docker images with the CLI command “docker image build”, also explained in the same article/walkthrough.



----------------------------------------------
--- Older simplified procedure - TO BE REMOVED
----------------------------------------------

## How to: dockerize the app
1. Add Docker files to the project:
   * In Visual Studio right click on the project -> Add-> Docker support
   * The docker-compose files are created plus the dcproj.
2. Add the environment variables to the docker-compose.override by using the [.env file](https://github.com/dotnet-architecture/eShopModernizing/blob/master/eShopModernizedMVCSolution/.env). Containers will use docker-compose environment variables and settings overriding values at the web.config, so the needed settings must be set at the docker-compose files and .env file. 
This environment variables must be setin the application and used instead of the web.config application settings. In our apps this is done in the CatalogConfiguration class.

## How to: run application in Windows Server 2016 with Containers
1. Create the docker image:
   * Build the solution in Release to build the eshopmodernizedmvc image.
   * When the build is done, open a Powershell prompt and execute ```docker images``` and in the list of images must appear eshopmodernizedmvc with tag _latest_
2. Publish the image in the Container Registry, in this case ACR:
   * Create one ACR on Azure. Take note of the address (e.g. myprivateacr.azurecr.io) and the user and password of the registry.
   * Login to the container registry. From a Powershell execute ```docker login -u dockerUser -p dockerPassword myprivateacr.azurecr.io``` using the values of your ACR
   * Add to the image our ACR address as a prefix to indicate where it must be published. Execute ```docker tag eshopmodernizedmvc myprivateacr.azurecr.io/eshopmodernizedmvc``` to mark it for publishing in the ACR. After this if you execute ```docker images``` this new _myprivateacr.azurecr.io/eshop/modernizedmvc must appear in the list of images.
   * Publish the tagged image executing ```docker push myprivateacr.azurecr.io/eshopmodernizedmvc```
   * Note: to publish in Docker hub instead of ACR, the login step is the same (with Docker Hub credentials), and skip the tag step because by default docker will publish to Docker Hub.
3. Run the image in the VM:
   * Create one VM in Azure. Select Windows Server 2016 Datacenter with containers. This way Docker is already installed and configured.
   * Install docker-compose. Following this [link](https://docs.docker.com/compose/install/#install-compose). Basically execute with admin rights from Powershell, with the last version, this command:  

      ```Invoke-WebRequest "https://github.com/docker/compose/releases/download/$dockerComposeVersion/docker-compose-Windows-x86_64.exe" -UseBasicParsing -OutFile $Env:ProgramFiles\docker\docker-compose.exe```

   * Copy the files _docker-compose.nobuild.yml_, _docker-compose.override.yml_ and _.env_ to the VM in a folder.
   * Edit the .env to put the IP of the VM in the variable.
   * Edit the _docker-compose.nobuild_ file to add the prefix of your ACR eshop/modernizedmvc:

          > image:myprivateacr.azurecr.io/eshop/modernizedmvc
 
   * If your image is in a private registry, login first. For ACR would be to execute in the VM ```docker login -u dockerUser -p dockerPassword myprivateacr.azurecr.io```.
   * Run ```docker-compose -f .\docker-compose.nobuild.yml -f .\docker-compose.override.yml up```. The first time the images will be downloaded from the registry, so this step can take some minutes the initial execution.
   * After this open the browser and write http://{ip of the VM}:5114 and the app should open.
 

