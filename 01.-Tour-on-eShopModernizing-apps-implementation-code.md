
##  Overview
In this walkthrough, you can simply explore the initial implementation of two sample legacy applications, with monolithic architecture, created with classic ASP.NET, one based on ASP.NET 4.x MVC and the second based on ASP.NET 4.x Web Forms, which are placed at the eShopModernizing GitHub repository. 
In a similar way you could be containerizing a classic WCF service (Windows Communication Foundation) that could be consumed by a desktop application, as in this other example (eShopModernizingWCFWinForms).

##  Goals for this walkthrough
Just to get familiar with these apps and its code and configuration, as you can configure the app so it generates and uses mock-data without using the SQL Database, if you want, for testing purposes. This optional config is based on Dependency Injection, in a decoupled way.

##  Scenario
The diagram below explains the simple scenario of the original legacy applications.
![image](https://user-images.githubusercontent.com/1712635/30354184-db7f1098-97df-11e7-8e7b-c18c67b8ba2a.png)

You can see the eShopLegacyMVC original legacy applications loaded in Visual Studio 2017.
![image](https://user-images.githubusercontent.com/1712635/30353284-d86d8afc-97d9-11e7-8cd5-276dbca82ce3.png)

Note that this application is a single monolithic application based on a single ASP.NET MVC project. In a similar way, the eShopLegacyWebForms applications is also a monolithic and single project based app. The only point in common for both applications is the catalog database, which is also the same database for the catalog microservice in [eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers). But these current monolithic scenarios we are covering here have nothing to do with microservices architecture but just with containers.

From a business domain perspective, both apps offer the same catalog management features, and would be used by members of the eShop enterprise team to view and edit the product catalog. You can see initial screenshots below.
![image](https://user-images.githubusercontent.com/1712635/30354210-0638f3b2-97e0-11e7-82c5-df18197ccdbd.png)
 
These are web applications used to browse and modify the catalog entries. The fact that both apps deliver the same business/functional features is simply because of comparison reasons so you can see a similar modernization process for apps created with the ASP.NET MVC and ASP.NET Web Forms frameworks.
The dependency taken on ASP.NET 4.x or older (either for Web Forms or MVC) means these applications will not run on .NET Core unless the code is fully re-written and instead uses ASP.NET Core MVC. But this is precisely the point, in this case you donâ€™t want to re-architect or re-write any code but just containerized these existing applications while still using the same .NET technologies and the same code. You will see how you can run applications like these in containers without changes.

## Database options
These monolithic web applications are designed as monolithic web application containing all the code, including the data access libraries. The database would run on a separate high-available environment, like a SQL Server cluster.

For development environments you have several choices in these applications and the SQL Server database:
1.	Run the database as a SQL localdb database running on the same Windows (Or Windows Container afterwards)
2.	Run the database as a separate SQL Server Windows Container
3.	Mock the database with mock data based on in-memory lists and objects (UseMockData=true) 
The third mode, access to a database is simulated in the sample code by using in-memory objects. However, this is an scenario just for testing the application in the case you want to isolate the application tests from the real database access or even for demo purposes. Therefore, you can run the applications against that fake data or access a real SQL Database. 

For production environments, we encourage you to deploy the databases to one of the following choices:
1.	Azure SQL Database
2.	Azure SQL Database Managed Instance
3.	SQL Server VM in Azure

In any case, this series of walkthrough will demonstrate the simplest migration path, where you move existing assets to run in a container without any code changes at all. This path is appropriate for applications that are monolithic or standalone.

## Running and testing the sample applications
Before you go ahead and containerized the apps, you can run and test the apps right away in Visual Studio by just opening the solutions and hitting F5. 
The data will get populated either from a SQL Server localdb or from objects in-memory if the configuration is set to "UseMockData = True".
![image](https://user-images.githubusercontent.com/1712635/30354850-1905b882-97e4-11e7-9620-ce0f25e5eb5f.png)

